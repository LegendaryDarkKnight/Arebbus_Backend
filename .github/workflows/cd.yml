name: CD - Deploy to Azure VM

on:
  workflow_run:
    workflows: ["CI - Build and Test"]
    types:
      - completed
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    environment:
      name: production

    steps:
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.VM_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment script
        run: |
          cat > deploy_script.sh << 'DEPLOY_EOF'
          #!/bin/bash
          set -e
          
          # Colors for output
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          BLUE='\033[0;34m'
          CYAN='\033[0;36m'
          NC='\033[0m' # No Color
          
          log() {
            echo -e "${CYAN}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"
          }
          
          success() {
            echo -e "${GREEN}[SUCCESS]${NC} $1"
          }
          
          error() {
            echo -e "${RED}[ERROR]${NC} $1"
          }
          
          warning() {
            echo -e "${YELLOW}[WARNING]${NC} $1"
          }
          
          info() {
            echo -e "${BLUE}[INFO]${NC} $1"
          }
          
          case "$1" in
            cleanup_containers)
              log "Checking for existing containers to cleanup..."
          
              # List of possible container names to clean up
              CONTAINER_NAMES="arebbus arebbus-backend arebbus_postgres"
              CONTAINERS_FOUND=false
          
              for container_name in $CONTAINER_NAMES; do
                # Check if container is running
                RUNNING_CONTAINER=$(docker ps -q -f name=^${container_name}$)
                if [ ! -z "$RUNNING_CONTAINER" ]; then
                  info "Stopping running ${container_name} container..."
                  docker stop $container_name
                  success "${container_name} container stopped"
                  CONTAINERS_FOUND=true
                fi
          
                # Check if container exists (including stopped ones)
                EXISTING_CONTAINER=$(docker ps -aq -f name=^${container_name}$)
                if [ ! -z "$EXISTING_CONTAINER" ]; then
                  info "Removing ${container_name} container..."
                  docker rm $container_name
                  success "${container_name} container removed"
                  CONTAINERS_FOUND=true
                fi
              done
          
              # Stop and remove docker-compose containers if they exist
              if [ -f docker-compose.yml ]; then
                info "Found docker-compose.yml, stopping services..."
                if docker-compose ps -q 2>/dev/null | grep -q .; then
                  docker-compose down --remove-orphans
                  success "Docker-compose services stopped and removed"
                  CONTAINERS_FOUND=true
                else
                  info "No running docker-compose services found"
                fi
              else
                info "No docker-compose.yml found"
              fi
          
              if [ "$CONTAINERS_FOUND" = "false" ]; then
                info "No existing containers found to cleanup"
              fi
          
              success "Container cleanup completed"
              ;;
          
            pull_and_cleanup_images)
              log "Pulling latest backend image and cleaning up old images..."
          
              # Pull the latest image
              docker pull $DOCKER_USERNAME/arebbus-backend:latest
              success "Latest image pulled successfully"
          
              # Check for old backend images to cleanup
              OLD_IMAGES=$(docker images $DOCKER_USERNAME/arebbus-backend --format "{{.ID}}" | grep -v $(docker images $DOCKER_USERNAME/arebbus-backend:latest --format "{{.ID}}") || true)
          
              if [ ! -z "$OLD_IMAGES" ]; then
                log "Removing old backend images..."
                echo "$OLD_IMAGES" | xargs -r docker rmi || warning "Some old images could not be removed"
                success "Old images cleanup completed"
              else
                info "No old backend images found to cleanup"
              fi
          
              # Clean up dangling images
              DANGLING_IMAGES=$(docker images -f "dangling=true" -q)
              if [ ! -z "$DANGLING_IMAGES" ]; then
                log "Removing dangling images..."
                docker image prune -f
                success "Dangling images cleaned up"
              else
                info "No dangling images found"
              fi
              ;;
          
            setup_docker_compose)
              log "Setting up docker-compose.yml file..."
          
              cat > docker-compose.yml << 'COMPOSE_EOF'
          version: '3.8'
          
          services:
            postgres:
              image: postgres:17-alpine
              container_name: arebbus_postgres
              environment:
                POSTGRES_USER: ${POSTGRES_USER}
                POSTGRES_PASSWORD: ${POSTGRES_PASS}
                POSTGRES_DB: Arebbus
              volumes:
                - postgres_data:/var/lib/postgresql/data
                - ./init-sql:/docker-entrypoint-initdb.d
              ports:
                - "5433:5432"
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
                interval: 10s
                timeout: 5s
                retries: 5
                start_period: 30s
              restart: unless-stopped
              networks:
                - arebbus-network
          
            arebbus-backend:
              image: ${DOCKER_USERNAME}/arebbus-backend:latest
              container_name: arebbus-backend
              depends_on:
                postgres:
                  condition: service_healthy
              environment:
                POSTGRES_URL: ${POSTGRES_URL}
                POSTGRES_USER: ${POSTGRES_USER}
                POSTGRES_PASS: ${POSTGRES_PASS}
                SECRET_KEY: ${SECRET_KEY}
                FRONTEND_URL: ${FRONTEND_URL}
                JAVA_OPTS: "-Xmx1g -Djava.security.egd=file:/dev/./urandom"
              ports:
                - "8080:6996"
              volumes:
                - arebbus_data:/app/data
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:6996/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 60s
              restart: unless-stopped
              networks:
                - arebbus-network
          
          volumes:
            postgres_data:
              driver: local
            arebbus_data:
              driver: local
          
          networks:
            arebbus-network:
              driver: bridge
          COMPOSE_EOF
          
              success "docker-compose.yml created successfully"
              ;;
          
            create_env_file)
              log "Creating .env file for docker-compose..."
          
              cat > .env << ENV_EOF
          DOCKER_USERNAME=$DOCKER_USERNAME
          POSTGRES_URL=$POSTGRES_URL
          POSTGRES_USER=$POSTGRES_USER
          POSTGRES_PASS=$POSTGRES_PASS
          SECRET_KEY=$SECRET_KEY
          FRONTEND_URL=$FRONTEND_URL
          ENV_EOF
          
              success ".env file created successfully"
              ;;
          
            start_services)
              log "Starting services with docker-compose..."
              docker-compose up -d
              success "Services started successfully"
              ;;
          
            wait_for_postgres)
              log "Waiting for PostgreSQL to be ready..."
              for i in {1..30}; do
                info "PostgreSQL health check attempt $i of 30..."
          
                if docker exec arebbus_postgres pg_isready -U $POSTGRES_USER > /dev/null 2>&1; then
                  success "PostgreSQL is ready!"
                  return 0
                else
                  warning "PostgreSQL not ready, waiting 10s..."
                  sleep 10
                fi
              done
              error "PostgreSQL failed to become ready after 5 minutes"
              exit 1
              ;;
          
            wait_for_backend)
              log "Waiting for backend application to be ready..."
              sleep 30  # Initial wait for startup
          
              for i in {1..20}; do
                info "Backend health check attempt $i of 20..."
          
                if curl -f "http://localhost:8080/health" 2>/dev/null; then
                  success "Backend application is ready!"
                  return 0
                else
                  warning "Backend not ready, waiting 15s..."
                  sleep 15
                fi
              done
              error "Backend application failed to become ready after 5 minutes"
              exit 1
              ;;
          
            check_services_status)
              log "Checking services status..."
          
              if [ -f docker-compose.yml ]; then
                docker-compose ps
          
                # Check if postgres service is running
                POSTGRES_CONTAINER=$(docker ps -q -f name=arebbus_postgres)
                if [ ! -z "$POSTGRES_CONTAINER" ]; then
                  success "PostgreSQL container is running"
                else
                  error "PostgreSQL container is not running"
                  exit 1
                fi
          
                # Check if backend service is running
                BACKEND_CONTAINER=$(docker ps -q -f name=arebbus-backend)
                if [ ! -z "$BACKEND_CONTAINER" ]; then
                  success "Backend container is running"
                else
                  error "Backend container is not running"
                  exit 1
                fi
          
                success "All services are running properly"
              else
                error "docker-compose.yml not found"
                exit 1
              fi
              ;;
          
            show_logs)
              log "Showing recent logs from services..."
              echo ""
          
              # Check if postgres container exists and show logs
              POSTGRES_CONTAINER=$(docker ps -q -f name=arebbus_postgres)
              if [ ! -z "$POSTGRES_CONTAINER" ]; then
                info "PostgreSQL logs (last 10 lines):"
                docker logs --tail 10 arebbus_postgres
              else
                warning "PostgreSQL container not found"
              fi
          
              echo ""
          
              # Check if backend container exists and show logs
              BACKEND_CONTAINER=$(docker ps -q -f name=arebbus-backend)
              if [ ! -z "$BACKEND_CONTAINER" ]; then
                info "Backend logs (last 20 lines):"
                docker logs --tail 20 arebbus-backend
              else
                warning "Backend container not found"
              fi
              ;;
          
            test_health_endpoints)
              log "Testing health endpoints..."
          
              # Test PostgreSQL connection
              info "Testing PostgreSQL connection..."
              if docker exec arebbus_postgres pg_isready -U $POSTGRES_USER > /dev/null 2>&1; then
                success "PostgreSQL connection test passed"
              else
                error "PostgreSQL connection test failed"
                exit 1
              fi
          
              # Test backend health endpoint
              info "Testing backend health endpoint..."
              if curl -f "http://localhost:8080/health" 2>/dev/null; then
                success "Backend health endpoint test passed"
              else
                error "Backend health endpoint test failed"
                exit 1
              fi
              ;;
          
            final_status)
              success "Deployment completed successfully!"
              info "Application is accessible at: http://$VM_HOST:8080"
              echo ""
              log "Final services status:"
              docker-compose ps
              echo ""
              log "Network information:"
              docker network ls | grep arebbus
              echo ""
              log "Volume information:"
              docker volume ls | grep -E "(postgres_data|arebbus_data)"
              ;;
          
            cleanup_deployment_files)
              log "Cleaning up deployment files..."
              FILES_TO_REMOVE="docker-compose.yml .env"
              FILES_REMOVED=false
          
              for file in $FILES_TO_REMOVE; do
                if [ -f "$file" ]; then
                  rm -f "$file"
                  info "Removed $file"
                  FILES_REMOVED=true
                fi
              done
          
              if [ "$FILES_REMOVED" = "false" ]; then
                info "No deployment files found to cleanup"
              else
                success "Deployment files cleaned up"
              fi
              ;;
          
            *)
              error "Unknown command: $1"
              exit 1
              ;;
          esac
          DEPLOY_EOF
          
          chmod +x deploy_script.sh

      - name: Upload deployment script
        run: |
          scp -i ~/.ssh/id_rsa deploy_script.sh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }}:/tmp/

      - name: Cleanup existing containers
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "/tmp/deploy_script.sh cleanup_containers"

      - name: Pull latest image and cleanup old images
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }} /tmp/deploy_script.sh pull_and_cleanup_images"

      - name: Setup docker-compose configuration
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "/tmp/deploy_script.sh setup_docker_compose"

      - name: Create environment file
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }} \
             POSTGRES_URL=${{ secrets.POSTGRES_URL }} \
             POSTGRES_USER=${{ secrets.POSTGRES_USER }} \
             POSTGRES_PASS=${{ secrets.POSTGRES_PASS }} \
             SECRET_KEY=${{ secrets.SECRET_KEY }} \
             FRONTEND_URL=${{ secrets.FRONTEND_URL }} \
             /tmp/deploy_script.sh create_env_file"

      - name: Start services with docker-compose
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "/tmp/deploy_script.sh start_services"

      - name: Wait for PostgreSQL to be ready
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "POSTGRES_USER=${{ secrets.POSTGRES_USER }} /tmp/deploy_script.sh wait_for_postgres"

      - name: Wait for backend application
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "/tmp/deploy_script.sh wait_for_backend"

      - name: Check services status
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "/tmp/deploy_script.sh check_services_status"

      - name: Show service logs
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "/tmp/deploy_script.sh show_logs"

      - name: Test health endpoints
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "POSTGRES_USER=${{ secrets.POSTGRES_USER }} /tmp/deploy_script.sh test_health_endpoints"

      - name: Show final deployment status
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "VM_HOST=${{ secrets.VM_HOST }} /tmp/deploy_script.sh final_status"

      - name: Cleanup
        if: always()
        run: |
          # Cleanup remote files
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "/tmp/deploy_script.sh cleanup_deployment_files && rm -f /tmp/deploy_script.sh" || true
          # Cleanup SSH key
          rm -f ~/.ssh/id_rsa