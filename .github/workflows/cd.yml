name: CD - Deploy to Azure VM

on:
  workflow_run:
    workflows: ["CI - Build and Test"]
    types:
      - completed
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    environment:
      name: production

    steps:
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.VM_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment script
        run: |
          cat > deploy_script.sh << 'DEPLOY_EOF'
          #!/bin/bash
          set -e
          
          # Colors for output
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          BLUE='\033[0;34m'
          CYAN='\033[0;36m'
          NC='\033[0m' # No Color
          
          log() {
            echo -e "${CYAN}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"
          }
          
          success() {
            echo -e "${GREEN}[SUCCESS]${NC} $1"
          }
          
          error() {
            echo -e "${RED}[ERROR]${NC} $1"
          }
          
          warning() {
            echo -e "${YELLOW}[WARNING]${NC} $1"
          }
          
          info() {
            echo -e "${BLUE}[INFO]${NC} $1"
          }
          
          case "$1" in
            cleanup_containers)
              log "Stopping and removing all existing containers..."
          
              # Stop and remove arebbus backend container if exists
              if docker ps -q -f name=arebbus-backend; then
                info "Stopping arebbus-backend container..."
                docker stop arebbus-backend
              fi
              if docker ps -aq -f name=arebbus-backend; then
                info "Removing arebbus-backend container..."
                docker rm arebbus-backend
              fi
          
              # Stop and remove postgres container if exists
              if docker ps -q -f name=arebbus_postgres; then
                info "Stopping arebbus_postgres container..."
                docker stop arebbus_postgres
              fi
              if docker ps -aq -f name=arebbus_postgres; then
                info "Removing arebbus_postgres container..."
                docker rm arebbus_postgres
              fi
          
              # Stop and remove docker-compose containers if they exist
              if [ -f docker-compose.yml ]; then
                info "Stopping docker-compose services..."
                docker-compose down || true
              fi
          
              success "Container cleanup completed"
              ;;
          
            pull_and_cleanup_images)
              log "Pulling latest backend image and cleaning up old images..."
          
              # Pull the latest image
              docker pull $DOCKER_USERNAME/arebbus-backend:latest
              success "Latest image pulled successfully"
          
              # Remove old backend images (keep only latest)
              log "Cleaning up old backend images..."
              docker images $DOCKER_USERNAME/arebbus-backend --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}" | grep -v latest | awk 'NR>1 {print $3}' | xargs -r docker rmi || true
          
              # Clean up dangling images
              docker image prune -f || true
          
              success "Image cleanup completed"
              ;;
          
            setup_docker_compose)
              log "Setting up docker-compose.yml file..."
          
              cat > docker-compose.yml << 'COMPOSE_EOF'
          version: '3.8'
          
          services:
            postgres:
              image: postgres:17-alpine
              container_name: arebbus_postgres
              environment:
                POSTGRES_USER: ${POSTGRES_USER}
                POSTGRES_PASSWORD: ${POSTGRES_PASS}
                POSTGRES_DB: Arebbus
              volumes:
                - postgres_data:/var/lib/postgresql/data
                - ./init-sql:/docker-entrypoint-initdb.d
              ports:
                - "5432:5432"
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
                interval: 10s
                timeout: 5s
                retries: 5
                start_period: 30s
              restart: unless-stopped
              networks:
                - arebbus-network
          
            arebbus-backend:
              image: ${DOCKER_USERNAME}/arebbus-backend:latest
              container_name: arebbus-backend
              depends_on:
                postgres:
                  condition: service_healthy
              environment:
                POSTGRES_URL: ${POSTGRES_URL}
                POSTGRES_USER: ${POSTGRES_USER}
                POSTGRES_PASS: ${POSTGRES_PASS}
                SECRET_KEY: ${SECRET_KEY}
                FRONTEND_URL: ${FRONTEND_URL}
                JAVA_OPTS: "-Xmx1g -Djava.security.egd=file:/dev/./urandom"
              ports:
                - "8080:6996"
              volumes:
                - arebbus_data:/app/data
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:6996/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 60s
              restart: unless-stopped
              networks:
                - arebbus-network
          
          volumes:
            postgres_data:
              driver: local
            arebbus_data:
              driver: local
          
          networks:
            arebbus-network:
              driver: bridge
          COMPOSE_EOF
          
              success "docker-compose.yml created successfully"
              ;;
          
            create_env_file)
              log "Creating .env file for docker-compose..."
          
              cat > .env << ENV_EOF
          DOCKER_USERNAME=$DOCKER_USERNAME
          POSTGRES_URL=$POSTGRES_URL
          POSTGRES_USER=$POSTGRES_USER
          POSTGRES_PASS=$POSTGRES_PASS
          SECRET_KEY=$SECRET_KEY
          FRONTEND_URL=$FRONTEND_URL
          ENV_EOF
          
              success ".env file created successfully"
              ;;
          
            start_services)
              log "Starting services with docker-compose..."
              docker-compose up -d
              success "Services started successfully"
              ;;
          
            wait_for_postgres)
              log "Waiting for PostgreSQL to be ready..."
              for i in {1..30}; do
                info "PostgreSQL health check attempt $i of 30..."
          
                if docker exec arebbus_postgres pg_isready -U $POSTGRES_USER > /dev/null 2>&1; then
                  success "PostgreSQL is ready!"
                  return 0
                else
                  warning "PostgreSQL not ready, waiting 10s..."
                  sleep 10
                fi
              done
              error "PostgreSQL failed to become ready after 5 minutes"
              exit 1
              ;;
          
            wait_for_backend)
              log "Waiting for backend application to be ready..."
              sleep 30  # Initial wait for startup
          
              for i in {1..20}; do
                info "Backend health check attempt $i of 20..."
          
                if curl -f "http://localhost:8080/health" 2>/dev/null; then
                  success "Backend application is ready!"
                  return 0
                else
                  warning "Backend not ready, waiting 15s..."
                  sleep 15
                fi
              done
              error "Backend application failed to become ready after 5 minutes"
              exit 1
              ;;
          
            check_services_status)
              log "Checking services status..."
              docker-compose ps
          
              # Check if both services are running
              if ! docker ps -q -f name=arebbus_postgres | grep -q .; then
                error "PostgreSQL container is not running"
                exit 1
              fi
          
              if ! docker ps -q -f name=arebbus-backend | grep -q .; then
                error "Backend container is not running"
                exit 1
              fi
          
              success "All services are running"
              ;;
          
            show_logs)
              log "Showing recent logs from services..."
              echo ""
              info "PostgreSQL logs (last 10 lines):"
              docker logs --tail 10 arebbus_postgres
              echo ""
              info "Backend logs (last 20 lines):"
              docker logs --tail 20 arebbus-backend
              ;;
          
            test_health_endpoints)
              log "Testing health endpoints..."
          
              # Test PostgreSQL connection
              info "Testing PostgreSQL connection..."
              if docker exec arebbus_postgres pg_isready -U $POSTGRES_USER > /dev/null 2>&1; then
                success "PostgreSQL connection test passed"
              else
                error "PostgreSQL connection test failed"
                exit 1
              fi
          
              # Test backend health endpoint
              info "Testing backend health endpoint..."
              if curl -f "http://localhost:8080/health" 2>/dev/null; then
                success "Backend health endpoint test passed"
              else
                error "Backend health endpoint test failed"
                exit 1
              fi
              ;;
          
            final_status)
              success "Deployment completed successfully!"
              info "Application is accessible at: http://$VM_HOST:8080"
              echo ""
              log "Final services status:"
              docker-compose ps
              echo ""
              log "Network information:"
              docker network ls | grep arebbus
              echo ""
              log "Volume information:"
              docker volume ls | grep -E "(postgres_data|arebbus_data)"
              ;;
          
            cleanup_deployment_files)
              log "Cleaning up deployment files..."
              rm -f docker-compose.yml .env
              success "Deployment files cleaned up"
              ;;
          
            *)
              error "Unknown command: $1"
              exit 1
              ;;
          esac
          DEPLOY_EOF
          
          chmod +x deploy_script.sh

      - name: Upload deployment script
        run: |
          scp -i ~/.ssh/id_rsa deploy_script.sh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }}:/tmp/

      - name: Cleanup existing containers
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "/tmp/deploy_script.sh cleanup_containers"

      - name: Pull latest image and cleanup old images
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }} /tmp/deploy_script.sh pull_and_cleanup_images"

      - name: Setup docker-compose configuration
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "/tmp/deploy_script.sh setup_docker_compose"

      - name: Create environment file
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }} \
             POSTGRES_URL=${{ secrets.POSTGRES_URL }} \
             POSTGRES_USER=${{ secrets.POSTGRES_USER }} \
             POSTGRES_PASS=${{ secrets.POSTGRES_PASS }} \
             SECRET_KEY=${{ secrets.SECRET_KEY }} \
             FRONTEND_URL=${{ secrets.FRONTEND_URL }} \
             /tmp/deploy_script.sh create_env_file"

      - name: Start services with docker-compose
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "/tmp/deploy_script.sh start_services"

      - name: Wait for PostgreSQL to be ready
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "POSTGRES_USER=${{ secrets.POSTGRES_USER }} /tmp/deploy_script.sh wait_for_postgres"

      - name: Wait for backend application
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "/tmp/deploy_script.sh wait_for_backend"

      - name: Check services status
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "/tmp/deploy_script.sh check_services_status"

      - name: Show service logs
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "/tmp/deploy_script.sh show_logs"

      - name: Test health endpoints
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "POSTGRES_USER=${{ secrets.POSTGRES_USER }} /tmp/deploy_script.sh test_health_endpoints"

      - name: Show final deployment status
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "VM_HOST=${{ secrets.VM_HOST }} /tmp/deploy_script.sh final_status"

      - name: Cleanup
        if: always()
        run: |
          # Cleanup remote files
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} \
            "/tmp/deploy_script.sh cleanup_deployment_files && rm -f /tmp/deploy_script.sh" || true
          # Cleanup SSH key
          rm -f ~/.ssh/id_rsa